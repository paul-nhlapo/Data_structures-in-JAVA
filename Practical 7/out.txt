---
toString
---
	a	b	c	d	e	f	g	h
a	0	0	0	0	1	-1	2	0
b	0	0	3	0	-2	0	0	-3
c	0	3	0	0	0	0	4	0
d	0	0	0	0	0	-4	5	0
e	1	-2	0	0	0	0	0	0
f	-1	0	0	-4	0	0	-5	6
g	2	0	4	5	0	-5	0	-6
h	0	-3	0	0	0	6	-6	0
---
unionFind
---
0	0	0	0	0	0	0	0	
3	6	1	7	0	4	5	2	
8	2	1	1	1	1	1	1	
1	1	1	1	1	1	1	1	
---
minSpanningTree
---
	a	b	c	d	e	f	g	h
a	0	0	0	0	0	-1	0	0
b	0	0	3	0	-2	0	0	-3
c	0	3	0	0	0	0	0	0
d	0	0	0	0	0	-4	0	0
e	0	-2	0	0	0	0	0	0
f	-1	0	0	-4	0	0	-5	0
g	0	0	0	0	0	-5	0	-6
h	0	-3	0	0	0	0	-6	0
---
colouring
---
b	g	
c	e	f	
a	d	h	


    // public void addVertex(String v) {

    // // Check if the vertex already exists in the graph.
    // for (int i = 0; i < vertices.length; i++) {
    // if (vertices[i].name.equals(v)) {
    // return;
    // }
    // }

    // if (vertices.length == 0) {
    // vertices = new Vertex[1];
    // vertices[0] = new Vertex(v);
    // } else {
    // Vertex[] temp = new Vertex[vertices.length + 1];
    // for (int i = 0; i < vertices.length; i++) {
    // temp[i] = vertices[i];
    // }
    // temp[temp.length - 1] = new Vertex(v);
    // vertices = temp;
    // }

    // // Sort the vertices array alphabetically by the vertex name.
    // for (int i = 0; i < vertices.length; i++) {
    // for (int j = 0; j < vertices.length - i - 1; j++) {
    // if (vertices[j].name.compareTo(vertices[j + 1].name) > 0) {
    // Vertex temp = vertices[j];
    // vertices[j] = vertices[j + 1];
    // vertices[j + 1] = temp;
    // }
    // }
    // }

    // }

    // public void removeVertex(String v) {
    // // Find the index of the vertex to be removed
    // int indexToRemove = -1;
    // for (int i = 0; i < vertices.length; i++) {
    // if (vertices[i].name.equals(v)) {
    // indexToRemove = i;
    // break;
    // }
    // }

    // // If the vertex is not found, do nothing
    // if (indexToRemove == -1) {
    // return;
    // }

    // // Create a new vertices array with reduced size
    // Vertex[] newVertices = new Vertex[vertices.length - 1];
    // int newIndex = 0;

    // // Copy vertices except for the one being removed
    // for (int i = 0; i < vertices.length; i++) {
    // if (i != indexToRemove) {
    // newVertices[newIndex] = vertices[i];
    // newIndex++;
    // }
    // }

    // // Update the vertices array
    // vertices = newVertices;

    // // Remove any edges connected to the removed vertex
    // removeEdgesWithVertex(v);
    // }

    // private void removeEdgesWithVertex(String v) {
    // // Create a new edges array with reduced size
    // Edge[] newEdges = new Edge[edges.length];
    // int newIndex = 0;

    // // Copy edges except for the ones connected to the removed vertex
    // for (Edge edge : edges) {
    // if (!(edge.vertexA.name.equals(v) || edge.vertexB.name.equals(v))) {
    // newEdges[newIndex] = edge;
    // newIndex++;
    // }
    // }

    // // Update the edges array
    // edges = new Edge[newIndex];
    // for (int i = 0; i < newIndex; i++) {
    // edges[i] = newEdges[i];
    // }

    // }

    // public void addEdge(String a, String b, int w) {
    // // Check if the vertices exist in the graph
    // Vertex vertexA = null;
    // Vertex vertexB = null;
    // for (Vertex vertex : vertices) {
    // if (vertex.name.equals(a)) {
    // vertexA = vertex;
    // }
    // if (vertex.name.equals(b)) {
    // vertexB = vertex;
    // }
    // }

    // // If either vertex is missing, do nothing
    // if (vertexA == null || vertexB == null) {
    // return;
    // }

    // // Check if the edge already exists in the graph
    // for (Edge edge : edges) {
    // if ((edge.vertexA == vertexA && edge.vertexB == vertexB) ||
    // (edge.vertexA == vertexB && edge.vertexB == vertexA)) {
    // return;
    // }
    // }

    // // Create the new edge and update the edges array
    // Edge newEdge = new Edge(vertexA, vertexB, w);
    // // Edge[] newEdges = Arrays.copyOf(edges, edges.length + 1);
    // Edge[] newEdges = new Edge[edges.length + 1];
    // for (int i = 0; i < edges.length; i++) {
    // newEdges[i] = edges[i];
    // }

    // newEdges[newEdges.length - 1] = newEdge;
    // // Sort the newEdges array using bubble sort
    // for (int i = 0; i < newEdges.length - 1; i++) {
    // for (int j = 0; j < newEdges.length - i - 1; j++) {
    // if (newEdges[j].compareTo(newEdges[j + 1]) > 0) {
    // // Swap the elements if they are out of order
    // Edge temp = newEdges[j];
    // newEdges[j] = newEdges[j + 1];
    // newEdges[j + 1] = temp;
    // }
    // }
    // }

    // edges = newEdges;
    // }

    // public void removeEdge(String a, String b) {
    // // Check if the vertices exist in the graph
    // Vertex vertexA = null;
    // Vertex vertexB = null;
    // for (Vertex vertex : vertices) {
    // if (vertex.name.equals(a)) {
    // vertexA = vertex;
    // }
    // if (vertex.name.equals(b)) {
    // vertexB = vertex;
    // }
    // }

    // // If either vertex is missing, do nothing
    // if (vertexA == null || vertexB == null) {
    // return;
    // }

    // // Find the edge to remove and update the edges array
    // boolean edgeRemoved = false;
    // Edge[] newEdges = new Edge[edges.length - 1];
    // int newIndex = 0;

    // for (Edge edge : edges) {
    // if ((edge.vertexA == vertexA && edge.vertexB == vertexB) ||
    // (edge.vertexA == vertexB && edge.vertexB == vertexA)) {
    // edgeRemoved = true;
    // } else {
    // newEdges[newIndex] = edge;
    // newIndex++;
    // }
    // }

    // // If the edge was removed, update the edges array
    // if (edgeRemoved) {
    // edges = newEdges;
    // }
    // }
	
    // public Vertex[][] brelazColouring() {

    // // Create a new array to store the colours
    // Vertex[][] colours = new Vertex[vertices.length][vertices.length];

    // // Create a new array to store the colour of each vertex
    // int[] vertexColours = new int[vertices.length];

    // // Initialize vertexColours array
    // for (int i = 0; i < vertices.length; i++) {
    // vertexColours[i] = -1;
    // }

    // // Sort the vertices array by degree
    // Vertex[] sortedVertices = new Vertex[vertices.length];
    // // Create a new array to store the degree of each vertex
    // int[] vertexDegrees = new int[vertices.length];
    // for (int i = 0; i < vertices.length; i++) {
    // sortedVertices[i] = vertices[i];
    // vertexDegrees[i] = getDegree(vertices[i]);
    // }
    // for (int i = 0; i < sortedVertices.length - 1; i++) {
    // for (int j = 0; j < sortedVertices.length - i - 1; j++) {
    // if (vertexDegrees[j] < vertexDegrees[j + 1]) {
    // Vertex temp = sortedVertices[j];
    // sortedVertices[j] = sortedVertices[j + 1];
    // sortedVertices[j + 1] = temp;

    // int tempDegree = vertexDegrees[j];
    // vertexDegrees[j] = vertexDegrees[j + 1];
    // vertexDegrees[j + 1] = tempDegree;
    // }
    // }
    // }

    // // Perform Brelaz's algorithm
    // for (Vertex vertex : sortedVertices) {
    // // Find the smallest colour that can be assigned to the vertex
    // int smallestColour = 0;
    // boolean colourFound = false;
    // while (!colourFound) {
    // boolean colourAvailable = true;
    // for (Edge edge : edges) {
    // if (edge.vertexA == vertex
    // && vertexColours[getPosition(edge.vertexB, vertices)] == smallestColour) {
    // colourAvailable = false;
    // break;
    // }
    // if (edge.vertexB == vertex
    // && vertexColours[getPosition(edge.vertexA, vertices)] == smallestColour) {
    // colourAvailable = false;
    // break;
    // }
    // }
    // if (colourAvailable) {
    // colourFound = true;
    // } else {
    // smallestColour++;
    // }
    // }

    // // Assign the smallest colour to the vertex
    // vertexColours[getPosition(vertex, vertices)] = smallestColour;
    // }

    // // Sort the vertices array by colour
    // Vertex[] sortedVerticesByColour = new Vertex[vertices.length];
    // for (int i = 0; i < vertices.length; i++) {
    // sortedVerticesByColour[i] = vertices[i];
    // }
    // for (int i = 0; i < sortedVerticesByColour.length - 1; i++) {
    // for (int j = 0; j < sortedVerticesByColour.length - i - 1; j++) {
    // if (vertexColours[j] > vertexColours[j + 1]) {
    // Vertex temp = sortedVerticesByColour[j];
    // sortedVerticesByColour[j] = sortedVerticesByColour[j + 1];
    // sortedVerticesByColour[j + 1] = temp;

    // int tempColour = vertexColours[j];
    // vertexColours[j] = vertexColours[j + 1];
    // vertexColours[j + 1] = tempColour;
    // }
    // }
    // }

    // // Sort the vertices in each colour by name
    // for (int i = 0; i < sortedVerticesByColour.length; i++) {
    // // Find the number of vertices with the current colour
    // int numVertices = 0;
    // for (int j = 0; j < sortedVerticesByColour.length; j++) {
    // if (vertexColours[j] == i) {
    // numVertices++;
    // }
    // }

    // // Create a new array to store the vertices with the current colour
    // Vertex[] verticesWithColour = new Vertex[numVertices];
    // int index = 0;
    // for (int j = 0; j < sortedVerticesByColour.length; j++) {
    // if (vertexColours[j] == i) {
    // verticesWithColour[index] = sortedVerticesByColour[j];
    // index++;
    // }
    // }

    // // Sort the vertices with the current colour by name
    // for (int j = 0; j < verticesWithColour.length - 1; j++) {
    // for (int k = 0; k < verticesWithColour.length - j - 1; k++) {
    // if (verticesWithColour[k].name.compareTo(verticesWithColour[k + 1].name) > 0)
    // {
    // Vertex temp = verticesWithColour[k];
    // verticesWithColour[k] = verticesWithColour[k + 1];
    // verticesWithColour[k + 1] = temp;
    // }
    // }
    // }

    // // Add the vertices with the current colour to the colours array
    // colours[i] = verticesWithColour;
    // }

    // return colours;
    // }

    // private int getDegree(Vertex vertex) {
    // int degree = 0;
    // for (Edge edge : edges) {
    // if (edge.vertexA == vertex || edge.vertexB == vertex) {
    // degree++;
    // }
    // }
    // return degree;
    // }